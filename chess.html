<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Special Chess</title>
<style>
    :root { --bg: #2d2d2d; --text: #eee; --board-border: #555; --light: #e0c090; --dark: #8a6040; --select: #7fc97f; --check: #ff5252; }
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: var(--bg); color: var(--text); padding: 10px; margin: 0; }
    h1 { margin: 5px 0; }
    
    /* Board */
    .board-container { position: relative; margin: 10px 0; }
    .board { display: grid; grid-template-columns: repeat(8, minmax(30px, min(8vw, 45px))); border: 3px solid var(--board-border); user-select: none; touch-action: manipulation; width: 100%; max-width: min(72vw, 360px); margin: 0 auto; }
    .square { aspect-ratio: 1; display: flex; justify-content: center; align-items: center; font-size: clamp(20px, min(5vw, 32px), 32px); cursor: pointer; position: relative; }
    .light { background: var(--light); color: black; } 
    .dark { background: var(--dark); color: black; }
    
    /* Piece States */
    .selected { background: var(--select) !important; }
    .check { background: var(--check) !important; }
    .hint::after { content: ''; position: absolute; width: 20%; height: 20%; background: rgba(0,0,0,0.3); border-radius: 50%; }
    .capture { background: #ff9800 !important; }
    .capture::after { content: ''; position: absolute; inset: 0; border: 4px solid rgba(180, 0, 0, 0.6); border-radius: 50%; }
    .ghost { opacity: 0.5; filter: grayscale(100%); }
    .revealed { outline: 3px dashed #d00; outline-offset: -3px; background-color: rgba(255, 0, 0, 0.2); }

    /* UI Elements */
    .controls, .game-options, .timer-container { width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 10px; margin-bottom: 10px; }
    .timer-container { flex-direction: row; justify-content: space-between; }
    
    .timer { background: #333; border-radius: 8px; padding: 10px; text-align: center; flex: 1; border: 2px solid transparent; }
    .timer.active { border-color: #4CAF50; }
    .timer-time { font-size: 1.2em; font-weight: bold; font-family: monospace; }
    
    .btn-row { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
    button { padding: 8px 16px; background: #444; color: white; border: 1px solid #666; border-radius: 4px; cursor: pointer; font-size: 14px; }
    button:hover { background: #555; }
    button.primary { background: #4CAF50; border-color: #4CAF50; }
    button.primary:hover { background: #45a049; }
    
    .game-options { background: #333; padding: 10px; border-radius: 8px; }
    .opt-row { display: flex; align-items: center; justify-content: space-between; margin: 5px 0; }
    .opt-row.horizontal { flex-direction: row; justify-content: space-around; flex-wrap: wrap; }
    .opt-item { display: flex; align-items: center; gap: 5px; min-width: 80px; }
    .opt-item span { font-size: clamp(20px, min(5vw, 32px), 32px); }
    .info-bubble { position: relative; display: inline-block; cursor: help; }
    .info-bubble .tooltip { visibility: hidden; width: 220px; background: #555; color: #fff; text-align: left; border-radius: 6px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -100px; opacity: 0; transition: opacity 0.3s; font-size: 11px; line-height: 1.3; }
    .info-bubble:hover .tooltip { visibility: visible; opacity: 1; }
    
    #status { height: 20px; color: #ffeb3b; font-weight: bold; text-align: center; }
    #moveHistory { max-height: 100px; overflow-y: auto; background: #222; padding: 5px; font-family: monospace; font-size: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
    
    /* Modal */
    .modal { position: absolute; inset: 0; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; }
    .promo-opts button { font-size: 32px; width: 50px; height: 50px; margin: 5px; }

    .hidden { display: none !important; }
</style>
</head>
<body>

    <h1>Special Chess</h1>
    <div id="turnDisplay">White's Turn</div>
    
    <div class="board-container">
        <div id="board" class="board"></div>
        <!-- Promotion Modal -->
        <div id="promotionModal" class="modal hidden">
            <h3 style="color:white">Promote to:</h3>
            <div id="promoOptions" class="promo-opts"></div>
        </div>
    </div>

    <div id="status"></div>

    <div class="timer-container hidden" id="timerContainer">
        <div id="whiteTimer" class="timer"><div class="lbl">White</div><div class="timer-time">10:00</div></div>
        <div id="blackTimer" class="timer"><div class="lbl">Black</div><div class="timer-time">10:00</div></div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <div class="btn-row hidden" id="assassinControls">
            <button id="btnAssassin" onclick="toggleAssassinView()">üëÅÔ∏è Show Assassin</button>
        </div>
        <div class="btn-row">
            <button onclick="undo()">‚Ü∂ Undo</button>
            <button onclick="redo()">‚Ü∑ Redo</button>
            <button onclick="saveGame()">üíæ Save</button>
            <button onclick="loadGame()">üìÅ Load</button>
        </div>
    </div>

    <!-- History -->
    <div id="moveHistory" class="hidden"></div>

    <!-- Options -->
    <div class="game-options">
        <div class="opt-row horizontal">
            <div class="opt-item">
                <label>
                    <span>‚è±Ô∏è</span>
                    <input type="checkbox" id="optTimer" checked>
                </label>
            </div>
            <div class="opt-item">
                <label>
                    <span>ü¶ï</span>
                    <input type="checkbox" id="optDino">
                </label>
            </div>
            <div class="opt-item">
                <label class="info-bubble">
                    <span>ü•∑</span>
                    <span class="tooltip">
                        <strong>Assassin Rules:</strong><br>
                        ‚Ä¢ Place in front of pawn (rank 3/6)<br>
                        ‚Ä¢ Hidden until enemy pawn attacks or passes<br>
                        ‚Ä¢ Moves 2 squares, captures 1<br>
                        ‚Ä¢ Can be blind-captured
                    </span>
                    <input type="checkbox" id="optAssassin">
                </label>
            </div>
        </div>
        <div class="btn-row" style="margin-top:10px">
            <button class="primary" onclick="initGame()">üéÆ Start New Game</button>
        </div>
    </div>

<script>
// --- CONSTANTS & CONFIG ---
const SYMBOLS = { 
    'K':'‚ôî','Q':'‚ôï','R':'‚ôñ','B':'‚ôó','N':'‚ôò','P':'‚ôô','T':'ü¶ï','A':'ü•∑üèª',
    'k':'‚ôö','q':'‚ôõ','r':'‚ôú','b':'‚ôù','n':'‚ôû','p':'‚ôü','t':'ü¶ñ','a':'ü•∑üèø' 
};
const VECTORS = {
    diag: [[1,1],[1,-1],[-1,1],[-1,-1]],
    orth: [[1,0],[-1,0],[0,1],[0,-1]],
    knight: [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]
};

// --- GLOBAL STATE ---
let state = {
    board: [],
    turn: 'white',
    selected: null,
    moves: [],
    castling: { w: {k:true, q:true}, b: {k:true, q:true} },
    enPassant: null,
    config: { timer: true, dino: false, assassin: false },
    assassinsPlaced: { w: false, b: false },
    showMyHidden: false,
    promotion: null,
    winner: null,
    history: [],    // For Undo/Redo (Snapshots)
    moveList: [],   // For Display (Notation)
    historyIndex: -1,
    timers: { white: 600, black: 600 },
    timerInterval: null
};

// --- INITIALIZATION ---
function initGame(loadedState = null) {
    if (state.timerInterval) clearInterval(state.timerInterval);

    if (loadedState) {
        state = loadedState;
        if (state.config.timer && !state.winner) startTimer();
    } else {
        const config = {
            timer: document.getElementById('optTimer').checked,
            dino: document.getElementById('optDino').checked,
            assassin: document.getElementById('optAssassin').checked
        };

        state = {
            board: createBoard(config),
            turn: 'white',
            selected: null,
            moves: [],
            castling: { w: {k:true, q:true}, b: {k:true, q:true} },
            enPassant: null,
            config: config,
            assassinsPlaced: { w: false, b: false },
            showMyHidden: false,
            promotion: null,
            winner: null,
            history: [],
            moveList: [],
            historyIndex: -1,
            timers: { white: 600, black: 600 },
            timerInterval: null
        };
        saveHistorySnapshot(); 
        if (config.timer) startTimer();
    }
    
    render();
}

function createBoard(config) {
    const b = Array(8).fill(null).map(() => Array(8).fill(null));
    const setRow = (r, p) => p.forEach((type, c) => b[r][c] = type);
    setRow(0, ['r','n','b','q','k','b','n','r']); 
    setRow(1, Array(8).fill('p'));
    setRow(6, Array(8).fill('P')); 
    setRow(7, ['R','N','B','Q','K','B','N','R']);
    
    if (config.dino) { b[5][4] = 'T'; b[2][4] = 't'; }
    return b;
}

// --- CORE LOGIC ---

function getEffectivePiece(r, c, board) {
    const p = board[r][c];
    if (!p) return null;
    if (state.config.assassin && p.toLowerCase() === 'a') {
        const isWhiteAss = (p === 'A');
        const enemyPawn = isWhiteAss ? 'p' : 'P';
        for (let pr = 0; pr < 8; pr++) {
            for (let pc = 0; pc < 8; pc++) {
                if (board[pr][pc] === enemyPawn) {
                    const attackRow = pr + (isWhiteAss ? 1 : -1);
                    if (attackRow === r && Math.abs(pc - c) === 1) return p; 
                    if (isWhiteAss && pr > r) return p; 
                    if (!isWhiteAss && pr < r) return p; 
                }
            }
        }
        return null; // Hidden
    }
    return p;
}

function handleClick(r, c) {
    if (state.winner || state.promotion) return;
    const isW = state.turn === 'white';
    
    // Assassin Setup
    if (state.config.assassin && !state.assassinsPlaced[isW ? 'w' : 'b']) {
        const validRow = isW ? 5 : 2; 
        const pawnRow = isW ? 6 : 1;
        const myPawn = isW ? 'P' : 'p';
        if (r === validRow && !state.board[r][c] && state.board[pawnRow][c] === myPawn) {
            state.board[r][c] = isW ? 'A' : 'a';
            state.assassinsPlaced[isW ? 'w' : 'b'] = true;
            endTurn();
        } else {
            showStatus("Must place Assassin in front of a pawn!", true);
        }
        return;
    }

    // Move or Select
    const move = state.moves.find(m => m.r === r && m.c === c);
    if (move) {
        makeMove(move);
        return;
    }

    const p = state.board[r][c];
    if (p && (p === p.toUpperCase()) === isW) {
        state.selected = {r, c};
        state.moves = getSafeMoves(r, c, p);
    } else {
        state.selected = null;
        state.moves = [];
    }
    render();
}

function makeMove(move) {
    const {r, c} = state.selected;
    const p = state.board[r][c];
    const isW = p === p.toUpperCase();
    
    // Notation
    const captured = state.board[move.r][move.c];
    let notation = p.toUpperCase() === 'P' && captured ? "px" : (p.toUpperCase() !== 'P' ? p.toUpperCase() : "");
    if (captured && p.toUpperCase() !== 'P') notation += "x";
    const files = "abcdefgh";
    notation += files[move.c] + (8-move.r);

    // Execute Move
    state.board[move.r][move.c] = p;
    state.board[r][c] = null;
    if (move.enPassant) state.board[r][move.c] = null;

    if (move.castle) {
        const row = isW ? 7 : 0;
        const rSrc = move.castle === 'k' ? 7 : 0;
        const rDst = move.castle === 'k' ? 5 : 3;
        state.board[row][rDst] = state.board[row][rSrc];
        state.board[row][rSrc] = null;
    }

    // Update Rights
    if (p.toLowerCase() === 'k') state.castling[isW?'w':'b'] = {k:false, q:false};
    if (p.toLowerCase() === 'r') {
        if (c === 0) state.castling[isW?'w':'b'].q = false;
        if (c === 7) state.castling[isW?'w':'b'].k = false;
    }
    
    state.enPassant = (p.toLowerCase() === 'p' && Math.abs(move.r - r) === 2) 
        ? { r: (r + move.r)/2, c: c } : null;

    if (p.toLowerCase() === 'p' && (move.r === 0 || move.r === 7)) {
        state.promotion = { r: move.r, c: move.c, notationBase: notation };
        render(); 
        return;
    }

    // Add to move history - show "A??" for hidden assassins
    if (p.toLowerCase() === 'a' && getEffectivePiece(r, c, state.board) === null) {
        state.moveList.push("A??");
    } else {
        state.moveList.push(notation);
    }
    endTurn();
}

function completePromotion(type) {
    const { r, c, notationBase } = state.promotion;
    const isW = state.turn === 'white';
    state.board[r][c] = isW ? type.toUpperCase() : type.toLowerCase();
    // Add assassin promotions to history
    if (type.toLowerCase() === 'a' && getEffectivePiece(r, c, state.board) === null) {
        state.moveList.push("A??=" + type.toUpperCase());
    } else {
        state.moveList.push(notationBase + "=" + type.toUpperCase());
    }
    state.promotion = null;
    endTurn();
}

function endTurn() {
    state.selected = null;
    state.moves = [];
    state.showMyHidden = false; 

    const wKing = findKing('white');
    const bKing = findKing('black');
    if (!wKing) state.winner = "Black Wins!";
    else if (!bKing) state.winner = "White Wins!";
    
    if (!state.winner) {
        state.turn = state.turn === 'white' ? 'black' : 'white';
        saveHistorySnapshot();
    }
    render();
}

// --- MOVEMENT HELPERS ---

function getSafeMoves(r, c, p) {
    return generateMoves(r, c, p, state.board).filter(m => {
        const simBoard = state.board.map(row => [...row]);
        simBoard[m.r][m.c] = simBoard[r][c];
        simBoard[r][c] = null;
        if (m.enPassant) simBoard[r][m.c] = null; 
        const myKing = findKing(state.turn, simBoard);
        return myKing && !isAttacked(myKing, state.turn, simBoard, state.board);
    });
}

function generateMoves(r, c, p, board, checkCastle = true) {
    const moves = [];
    const type = p.toLowerCase();
    const isW = p === p.toUpperCase();
    const opp = (pc) => pc && (isW ? pc === pc.toLowerCase() : pc === pc.toUpperCase());
    const onBoard = (tr, tc) => tr >= 0 && tr < 8 && tc >= 0 && tc < 8;
    const add = (tr, tc, extra={}) => { if (onBoard(tr,tc)) moves.push({r:tr, c:tc, ...extra}); };

    // 1. Pawn
    if (type === 'p') {
        const dir = isW ? -1 : 1;
        if (onBoard(r+dir, c) && !getEffectivePiece(r+dir, c, board)) {
            add(r+dir, c);
            if ((isW && r===6) || (!isW && r===1)) {
                if (!getEffectivePiece(r+dir*2, c, board)) add(r+dir*2, c);
            }
        }
        [[1,-1], [1,1]].forEach(([dr, dc]) => {
            const tr = r + (dir*dr), tc = c + dc;
            if (!onBoard(tr, tc)) return;
            const target = getEffectivePiece(tr, tc, board);
            if (target && opp(target)) add(tr, tc);
            if (state.enPassant && state.enPassant.r === tr && state.enPassant.c === tc) {
                add(tr, tc, { enPassant: true });
            }
        });
    } 
    // 2. Assassin
    else if (type === 'a') {
        for (let dr = -2; dr <= 2; dr++) {
            for (let dc = -2; dc <= 2; dc++) {
                if (dr===0 && dc===0) continue;
                const tr = r+dr, tc = c+dc;
                if (!onBoard(tr, tc)) continue;
                const dist = Math.max(Math.abs(dr), Math.abs(dc));
                const target = getEffectivePiece(tr, tc, board);
                if (dist === 2 && target === null) add(tr, tc);
                else if (dist === 1 && (target === null || opp(target))) add(tr, tc);
            }
        }
    }
    // 3. Others (Knight, Bishop, Rook, Queen, King, Dinosaur)
    else {
        // A. Jumps (Knight OR Dinosaur)
        if (type === 'n' || type === 't') {
            VECTORS.knight.forEach(([dr, dc]) => {
                const tr = r + dr, tc = c + dc;
                if (onBoard(tr, tc)) {
                    const target = getEffectivePiece(tr, tc, board);
                    if (!target || opp(target)) add(tr, tc);
                }
            });
        }

        // B. Sliding/Stepping (All EXCEPT Knight)
        if (type !== 'n') {
            // Determine Vectors
            const dirs = (type === 'b') ? VECTORS.diag :
                         (type === 'r') ? VECTORS.orth :
                         [...VECTORS.diag, ...VECTORS.orth]; // Q, K, T use both
            
            // Determine if Sliding (K is step, T/Q/R/B are slide)
            const slide = ['q','r','b','t'].includes(type);

            dirs.forEach(([dr, dc]) => {
                let tr = r + dr, tc = c + dc;
                while (onBoard(tr, tc)) {
                    const target = getEffectivePiece(tr, tc, board);
                    if (target) {
                        if (opp(target)) add(tr, tc);
                        break;
                    }
                    add(tr, tc);
                    if (!slide) break; // King stops after 1
                    tr += dr; tc += dc;
                }
            });

            // Castling (King only)
            if (type === 'k' && checkCastle && !isAttacked({r,c}, isW?'white':'black', board)) {
                const rights = isW ? state.castling.w : state.castling.b;
                const row = isW ? 7 : 0;
                const checkEmpty = (cols) => cols.every(col => !getEffectivePiece(row, col, board));
                
                if (rights.k && checkEmpty([5,6]) && !isAttacked({r:row, c:5}, isW?'white':'black', board)) 
                    add(row, 6, {castle: 'k'});
                if (rights.q && checkEmpty([1,2,3]) && !isAttacked({r:row, c:3}, isW?'white':'black', board)) 
                    add(row, 2, {castle: 'q'});
            }
        }
    }
    return moves;
}

function isAttacked(pos, myColor, board, visibilityBoard = null) {
    const visBoard = visibilityBoard || board;
    for (let r=0; r<8; r++) {
        for (let c=0; c<8; c++) {
            const p = board[r][c];
            if (p && ((myColor === 'white' && p === p.toLowerCase()) || (myColor === 'black' && p === p.toUpperCase()))) {
                if (state.config.assassin && p.toLowerCase() === 'a' && getEffectivePiece(r, c, visBoard) === null) continue;
                const moves = generateMoves(r, c, p, board, false);
                if (moves.some(m => m.r === pos.r && m.c === pos.c)) return true;
            }
        }
    }
    return false;
}

function findKing(color, board = state.board) {
    const k = color === 'white' ? 'K' : 'k';
    for(let r=0; r<8; r++) for(let c=0; c<8; c++) if (board[r][c] === k) return {r, c};
    return null;
}

// --- UTILITIES ---

function toggleAssassinView() {
    state.showMyHidden = !state.showMyHidden;
    render();
}

function startTimer() {
    state.timerInterval = setInterval(() => {
        if (state.winner) return clearInterval(state.timerInterval);
        if (state.timers[state.turn] > 0) {
            state.timers[state.turn]--;
            renderTimer();
        } else {
            state.winner = (state.turn === 'white' ? 'Black' : 'White') + " wins on time!";
            render();
            clearInterval(state.timerInterval);
        }
    }, 1000);
}

function renderTimer() {
    const format = t => `${Math.floor(t/60)}:${(t%60).toString().padStart(2,'0')}`;
    document.querySelector('#whiteTimer .timer-time').textContent = format(state.timers.white);
    document.querySelector('#blackTimer .timer-time').textContent = format(state.timers.black);
    document.getElementById('whiteTimer').className = `timer ${state.turn==='white'?'active':''}`;
    document.getElementById('blackTimer').className = `timer ${state.turn==='black'?'active':''}`;
}

function showStatus(msg, isError = false) {
    const el = document.getElementById('status');
    el.textContent = msg;
    el.style.color = isError ? '#ff5252' : '#ffeb3b';
}

function saveHistorySnapshot() {
    const snapshot = JSON.parse(JSON.stringify({
        board: state.board,
        turn: state.turn,
        castling: state.castling,
        enPassant: state.enPassant,
        config: state.config,
        assassinsPlaced: state.assassinsPlaced,
        moveList: state.moveList,
        timers: state.timers
    }));
    state.history = state.history.slice(0, state.historyIndex + 1);
    state.history.push(snapshot);
    state.historyIndex++;
}

function undo() {
    if (state.historyIndex > 0) {
        state.historyIndex--;
        restoreSnapshot(state.history[state.historyIndex]);
    }
}

function redo() {
    if (state.historyIndex < state.history.length - 1) {
        state.historyIndex++;
        restoreSnapshot(state.history[state.historyIndex]);
    }
}

function restoreSnapshot(snap) {
    state.board = JSON.parse(JSON.stringify(snap.board)); 
    state.turn = snap.turn;
    state.castling = JSON.parse(JSON.stringify(snap.castling));
    state.enPassant = snap.enPassant;
    state.assassinsPlaced = JSON.parse(JSON.stringify(snap.assassinsPlaced));
    state.moveList = [...snap.moveList];
    state.timers = {...snap.timers};
    state.selected = null;
    state.moves = [];
    state.promotion = null;
    state.winner = null;
    render();
}

function saveGame() {
    const data = JSON.stringify(state);
    const blob = new Blob([data], {type: 'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'special-chess.json';
    a.click();
}

function loadGame() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = evt => initGame(JSON.parse(evt.target.result));
        reader.readAsText(file);
    };
    input.click();
}

// --- RENDER ---
function render() {
    const isW = state.turn === 'white';
    
    document.getElementById('turnDisplay').textContent = state.winner || `${state.turn.toUpperCase()}'s Turn`;
    showStatus('');
    
    if (state.winner) {
        showStatus(state.winner);
    } else if (state.config.assassin && !state.assassinsPlaced[isW?'w':'b']) {
        showStatus(`Place your Assassin on Rank ${isW?3:6} (Front of Pawn)`);
    } else {
        const myKing = findKing(state.turn);
        if (myKing && isAttacked(myKing, state.turn, state.board)) {
            let hasMove = false;
            for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                const p = state.board[r][c];
                if(p && ((isW && p===p.toUpperCase()) || (!isW && p===p.toLowerCase()))) {
                    if(getSafeMoves(r,c,p).length > 0) { hasMove=true; break; }
                }
            }
            showStatus(hasMove ? "Check!" : "Checkmate!", !hasMove);
            if (!hasMove) state.winner = (isW ? "Black" : "White") + " Wins!";
        }
    }

    const el = document.getElementById('board'); 
    el.innerHTML = '';
    state.board.forEach((row, r) => row.forEach((p, c) => {
        const div = document.createElement('div');
        div.className = `square ${(r+c)%2 ? 'dark' : 'light'}`;
        
        if (p) {
            const pColor = p === p.toUpperCase() ? 'white' : 'black';
            const isMine = pColor === state.turn;
            let show = true;
            let opacity = 1;

            if (state.config.assassin && p.toLowerCase() === 'a') {
                const hidden = getEffectivePiece(r, c, state.board) === null;
                if (hidden) {
                    if (isMine && state.showMyHidden) { opacity = 0.5; }
                    else { show = false; }
                } else if (!hidden) {
                    div.classList.add('revealed');
                }
            }

            if (show) {
                div.textContent = SYMBOLS[p];
                div.style.opacity = opacity;
                if (p.toLowerCase() === 'k' && inCheck(pColor)) div.classList.add('check');
            }
        }
        
        if (state.selected?.r === r && state.selected?.c === c) div.classList.add('selected');
        
        const move = state.moves.find(m => m.r === r && m.c === c);
        if (move) {
            const target = getEffectivePiece(r, c, state.board);
            div.classList.add((target || move.enPassant) ? 'capture' : 'hint');
        }

        div.onclick = () => handleClick(r, c);
        el.appendChild(div);
    }));

    const toggle = (id, cond) => document.getElementById(id).classList.toggle('hidden', !cond);
    toggle('timerContainer', state.config.timer);
    toggle('assassinControls', state.config.assassin);
    toggle('moveHistory', state.moveList.length > 0);
    toggle('promotionModal', !!state.promotion);

    document.getElementById('btnAssassin').textContent = state.showMyHidden ? "üëÅÔ∏è Hide Assassin" : "üëÅÔ∏è Show Assassin";

    const histEl = document.getElementById('moveHistory');
    histEl.innerHTML = state.moveList.map((m, i) => `<div>${Math.floor(i/2)+1}.${i%2?'..':''} ${m}</div>`).join('');
    histEl.scrollTop = histEl.scrollHeight;
    
    if (state.promotion) {
        const opts = document.getElementById('promoOptions');
        opts.innerHTML = '';
        ['q','r','b','n', (state.config.dino?'t':null), (state.config.assassin?'a':null)]
            .filter(x=>x).forEach(t => {
                const b = document.createElement('button');
                b.textContent = SYMBOLS[isW ? t.toUpperCase() : t];
                b.onclick = () => completePromotion(t);
                opts.appendChild(b);
            });
    }

    if (state.config.timer) renderTimer();
}

function inCheck(color) {
    const k = findKing(color);
    return k && isAttacked(k, color, state.board);
}

initGame();
</script>
</body>
</html>
