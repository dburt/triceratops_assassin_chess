<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Special Chess</title>
<style>
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f0f0; padding: 20px; }
    .board { display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px); border: 2px solid #333; user-select: none; }
    .square { width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; font-size: 40px; cursor: pointer; position: relative; }
    .light { background: #f0d9b5; } .dark { background: #b58863; }
    .selected { background: #7fc97f !important; }
    .check { background: #ff5252 !important; }
    .hint::after { content: ''; position: absolute; width: 20px; height: 20px; background: rgba(0,0,0,0.2); border-radius: 50%; }
    .capture { background: #ff9800 !important; }
    .capture::after { content: ''; position: absolute; inset: 0; border: 4px solid rgba(180, 0, 0, 0.5); border-radius: 50%; }
    .controls { margin-top: 15px; display: flex; gap: 10px; }
    button { padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; }
    button:hover { background: #45a049; }
    #status { font-weight: bold; margin: 10px 0; min-height: 24px; text-align: center; }
</style>
</head>
<body>
    <h1>Special Chess</h1>
    <div id="turnDisplay">White's Turn</div>
    <div id="board" class="board"></div>
    <div id="status"></div>
    <div class="controls">
        <button onclick="initGame('standard')">New game</button>
        <button onclick="initGame('dinosaur')">New game with dinosaurs</button>
        <button onclick="initGame('assassin')">New game with assassins</button>
        <button id="btnAssassin" onclick="toggleAssassin()" style="display:none">Show My Assassin</button>
    </div>

<script>
const SYMBOLS = { 'K':'â™”','Q':'â™•','R':'â™–','B':'â™—','N':'â™˜','P':'â™™','T':'ðŸ¦•','A':'ðŸ¥·ðŸ»',
                  'k':'â™š','q':'â™›','r':'â™œ','b':'â™','n':'â™ž','p':'â™Ÿ','t':'ðŸ¦–','a':'ðŸ¥·ðŸ¿' };
const VECTORS = {
    diagonals: [[1,1],[1,-1],[-1,1],[-1,-1]],
    orthogonals: [[1,0],[-1,0],[0,1],[0,-1]],
    knight: [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]
};

let state = { board: [], turn: 'white', selected: null, moves: [], castling: {}, enPassant: null, mode: 'standard', assassins: {w:0, b:0}, showHidden: false };

function initGame(mode) {
    state = { 
        board: createBoard(mode), turn: 'white', selected: null, moves: [], 
        castling: { w: {k:1,q:1}, b: {k:1,q:1} }, enPassant: null, mode: mode, 
        assassins: { w: false, b: false }, showHidden: false 
    };
    document.getElementById('btnAssassin').style.display = mode === 'assassin' ? 'block' : 'none';
    render();
}

function createBoard(mode) {
    const b = Array(8).fill(null).map(() => Array(8).fill(null));
    const setRow = (r, p) => p.forEach((type, c) => b[r][c] = type);
    setRow(0, ['r','n','b','q','k','b','n','r']); setRow(1, Array(8).fill('p'));
    setRow(6, Array(8).fill('P')); setRow(7, ['R','N','B','Q','K','B','N','R']);
    if (mode === 'dinosaur') { b[5][4] = 'T'; b[2][4] = 't'; } 
    return b;
}

function render() {
    const el = document.getElementById('board'); el.innerHTML = '';
    const turnTxt = document.getElementById('turnDisplay');
    const statusTxt = document.getElementById('status');
    const isW = state.turn === 'white';
    
    turnTxt.textContent = `${state.turn.charAt(0).toUpperCase() + state.turn.slice(1)}'s Turn`;
    statusTxt.textContent = '';
    
    // Status Messages
    if (state.mode === 'assassin' && !state.assassins[state.turn.charAt(0)]) {
        statusTxt.textContent = `Place your Assassin on rank ${isW ? 3 : 6}`; 
        statusTxt.style.color = 'green';
    } else if (inCheck(state.turn)) {
        statusTxt.textContent = hasMoves(state.turn) ? "Check!" : "Checkmate!";
        statusTxt.style.color = 'red';
    }

    state.board.forEach((row, r) => row.forEach((p, c) => {
        const div = document.createElement('div');
        div.className = `square ${(r+c)%2 ? 'dark' : 'light'}`;
        
        // Piece Rendering logic
        if (p) {
            const pColor = p === p.toUpperCase() ? 'white' : 'black';
            const isAssassin = p.toLowerCase() === 'a';
            const isMine = pColor === state.turn;
            
            // Logic: Show if NOT assassin, OR if it's my assassin AND showHidden is true. Otherwise empty.
            if (!isAssassin) div.textContent = SYMBOLS[p];
            else if (isMine && state.showHidden) div.textContent = SYMBOLS[p];
            else div.textContent = ''; 

            if (p.toLowerCase() === 'k' && isMine && inCheck(state.turn)) div.classList.add('check');
        }

        if (state.selected && state.selected.r === r && state.selected.c === c) div.classList.add('selected');
        
        const move = state.moves.find(m => m.r === r && m.c === c);
        // Highlight move if it's a capture, or an en-passant capture
        if (move) div.classList.add((state.board[r][c] || move.enPassant) ? 'capture' : 'hint');

        div.onclick = () => handleClick(r, c);
        el.appendChild(div);
    }));
}

function handleClick(r, c) {
    const p = state.board[r][c];
    const isW = state.turn === 'white';
    
    // 1. Assassin Placement Phase
    if (state.mode === 'assassin' && !state.assassins[isW?'w':'b']) {
        if ((isW && r === 5 && !p) || (!isW && r === 2 && !p)) {
            state.board[r][c] = isW ? 'A' : 'a';
            state.assassins[isW?'w':'b'] = true;
            nextTurn();
        }
        return;
    }

    // 2. Move Selection
    const move = state.moves.find(m => m.r === r && m.c === c);
    if (move) {
        executeMove(move);
    } else if (p && (isW ? p === p.toUpperCase() : p === p.toLowerCase())) {
        state.selected = {r, c};
        state.moves = getSafeMoves(r, c, p);
        render();
    } else {
        state.selected = null;
        state.moves = [];
        render();
    }
}

function getSafeMoves(r, c, p) {
    return generateMoves(r, c, p).filter(m => {
        const saved = { ...state, board: state.board.map(row => [...row]) };
        // Simulate Move
        saved.board[m.r][m.c] = saved.board[r][c];
        saved.board[r][c] = null;
        if (m.enPassant) saved.board[r][m.c] = null; // Captured pawn is at [sourceRow][targetCol]
        
        return !isAttacked(findKing(saved.board, state.turn), saved.turn, saved.board);
    });
}

function generateMoves(r, c, p, board = state.board, checkCastling = true) {
    const moves = [];
    const type = p.toLowerCase();
    const isW = p === p.toUpperCase();
    const opp = (pc) => pc && (isW ? pc === pc.toLowerCase() : pc === pc.toUpperCase());
    const empty = (r, c) => board[r][c] === null;
    const add = (tr, tc, extra={}) => { if(onBoard(tr, tc)) moves.push({r:tr, c:tc, ...extra}); };

    if (type === 'p') {
        const dir = isW ? -1 : 1;
        const start = isW ? 6 : 1;
        if (empty(r+dir, c)) {
            add(r+dir, c);
            if (r === start && empty(r+dir*2, c)) add(r+dir*2, c);
        }
        // Captures & En Passant
        [[r+dir, c-1], [r+dir, c+1]].forEach(([tr, tc]) => {
            if (onBoard(tr, tc)) {
                if (opp(board[tr][tc])) add(tr, tc);
                // Check En Passant: target matches state.enPassant (shadow square)
                else if (state.enPassant && state.enPassant.r === tr && state.enPassant.c === tc) {
                    add(tr, tc, { enPassant: true });
                }
            }
        });
    } else if (['n','k','a'].includes(type)) { // Stepping pieces
        (type==='n' ? VECTORS.knight : [...VECTORS.orthogonals, ...VECTORS.diagonals]).forEach(([dr, dc]) => {
            const tr=r+dr, tc=c+dc;
            if (onBoard(tr, tc) && (!board[tr][tc] || opp(board[tr][tc]))) add(tr, tc);
        });
        // Castling
        if (type === 'k' && checkCastling && !inCheck(state.turn)) {
            const row = isW ? 7 : 0;
            const rights = isW ? state.castling.w : state.castling.b;
            if (rights.k && empty(row, 5) && empty(row, 6) && !isAttacked({r:row, c:5}, state.turn, board)) add(row, 6, {castle: 'k'});
            if (rights.q && empty(row, 1) && empty(row, 2) && empty(row, 3) && !isAttacked({r:row, c:3}, state.turn, board)) add(row, 2, {castle: 'q'});
        }
    } else { // Sliding (B, R, Q, T)
        const dirs = type==='b' ? VECTORS.diagonals : type==='r' ? VECTORS.orthogonals : [...VECTORS.orthogonals, ...VECTORS.diagonals];
        
        if (type === 't') { // Triceratops
            // King moves (one square in any direction)
            [...VECTORS.orthogonals, ...VECTORS.diagonals].forEach(([dr, dc]) => {
                const tr=r+dr, tc=c+dc; if(onBoard(tr, tc) && (!board[tr][tc] || opp(board[tr][tc]))) add(tr, tc);
            });
            // Knight moves
            VECTORS.knight.forEach(([dr, dc]) => {
                 const tr=r+dr, tc=c+dc; if(onBoard(tr, tc) && (!board[tr][tc] || opp(board[tr][tc]))) add(tr, tc);
            });
            // Bishop moves (with jumping)
            VECTORS.diagonals.forEach(([dr, dc]) => {
                let jumped = false;
                for (let i=1; i<8; i++) {
                    const tr=r+dr*i, tc=c+dc*i;
                    if (!onBoard(tr, tc)) break;
                    const cell = board[tr][tc];
                    if (!cell) add(tr, tc);
                    else if (opp(cell)) { add(tr, tc); if(jumped) break; jumped=true; }
                    else break;
                }
            });
        } else { // Regular Sliders
            dirs.forEach(([dr, dc]) => {
                for (let i=1; i<8; i++) {
                    const tr=r+dr*i, tc=c+dc*i;
                    if (!onBoard(tr, tc)) break;
                    if (!board[tr][tc]) add(tr, tc);
                    else { if (opp(board[tr][tc])) add(tr, tc); break; }
                }
            });
        }
    }
    return moves;
}

function executeMove(move) {
    const {r, c} = state.selected;
    const p = state.board[r][c];
    const isW = state.turn === 'white';
    
    // 1. Move piece to target
    state.board[move.r][move.c] = p;
    state.board[r][c] = null;

    // 2. Handle En Passant Capture
    if (move.enPassant) {
        // Remove the pawn that was passed (same row as source, col of target)
        state.board[r][move.c] = null;
    }

    // 3. Handle Castling (Move Rook)
    if (move.castle) {
        const row = isW ? 7 : 0;
        const rookCol = move.castle === 'k' ? 7 : 0;
        const targetRookCol = move.castle === 'k' ? 5 : 3;
        state.board[row][targetRookCol] = state.board[row][rookCol];
        state.board[row][rookCol] = null;
    }

    // 4. Promotion
    if (p.toLowerCase() === 'p' && (move.r === 0 || move.r === 7)) {
        state.board[move.r][move.c] = isW ? 'Q' : 'q';
    }
    
    // 5. Set En Passant Target for NEXT turn
    // If pawn moved 2 squares, target is the square in between
    state.enPassant = (p.toLowerCase() === 'p' && Math.abs(move.r - r) === 2) 
        ? { r: (r + move.r) / 2, c: c } 
        : null;

    // 6. Update Castling Rights
    if (p.toLowerCase() === 'k') state.castling[isW?'w':'b'] = {k:0, q:0};
    if (p.toLowerCase() === 'r') {
        if (c === 0) state.castling[isW?'w':'b'].q = 0;
        if (c === 7) state.castling[isW?'w':'b'].k = 0;
    }

    nextTurn();
}

function nextTurn() {
    state.turn = state.turn === 'white' ? 'black' : 'white';
    state.selected = null;
    state.moves = [];
    state.showHidden = false; // Always reset visibility on turn change
    render();
}

function inCheck(color) { return isAttacked(findKing(state.board, color), color, state.board); }
function findKing(b, color) {
    for(let r=0; r<8; r++) for(let c=0; c<8; c++) if(b[r][c] === (color==='white'?'K':'k')) return {r, c};
}
function isAttacked(pos, color, board) {
    if (!pos) return false;
    // Check if any enemy piece can move to 'pos'
    for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
        const p = board[r][c];
        if (p && ((color === 'white' && p === p.toLowerCase()) || (color === 'black' && p === p.toUpperCase()))) {
            // Generate raw moves (ignoring castling/check checks to prevent recursion)
            if (generateMoves(r, c, p, board, false).some(m => m.r === pos.r && m.c === pos.c)) return true;
        }
    }
    return false;
}
function hasMoves(color) {
    for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
        const p = state.board[r][c];
        if (p && (color==='white'?p===p.toUpperCase():p===p.toLowerCase())) {
            if (getSafeMoves(r, c, p).length > 0) return true;
        }
    }
    return false;
}
function toggleAssassin() { state.showHidden = !state.showHidden; render(); }
function onBoard(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }

initGame('standard');
</script>
</body>
</html>
